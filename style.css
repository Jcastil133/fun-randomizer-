/* script.js - Fun Randomizer + Match Game Mode
   Drop into fun-randomizer/script.js
*/
(function(){
  // ---- helpers ----
  const $ = s => document.querySelector(s);
  const id = s => document.getElementById(s);

  // elements
  const namesEl = id('names');
  const teamsCountEl = id('teamsCount');
  const teamSizeEl = id('teamSize');
  const shuffleBtn = id('shuffleBtn');
  const clearBtn = id('clearBtn');
  const randomNameBtn = id('randomNameBtn');
  const allowUneven = id('allowUneven');
  const results = id('results');

  // manual teams
  const manualTeamName = id('manualTeamName');
  const addManualTeam = id('addManualTeam');
  const manualTeamsList = id('manualTeamsList');

  // match game
  const tilesContainer = id('tiles');
  const revealRandom = id('revealRandom');
  const resetTiles = id('resetTiles');
  const teamSelect = id('teamSelect');
  const saleSize = id('saleSize');
  const recordSale = id('recordSale');
  const removeTileBtn = id('removeTileBtn');
  const puzzleAnswerEl = id('puzzleAnswer');
  const guessInput = id('guessInput');
  const submitGuess = id('submitGuess');
  const gameLog = id('gameLog');

  // confetti
  const confettiCanvas = id('confetti');
  const ctx = confettiCanvas.getContext && confettiCanvas.getContext('2d');

  function resizeCanvas(){ confettiCanvas.width = window.innerWidth; confettiCanvas.height = window.innerHeight; }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // simple shuffle
  function shuffleArr(a){
    for(let i=a.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [a[i],a[j]]=[a[j],a[i]];
    }
    return a;
  }

  // demo
  const demo = ['Ava','Ben','Carmen','Derek','Ethan','Faye','Gabe','Hannah','Ivy','Jason','Kira','Liam'];
  randomNameBtn.addEventListener('click', ()=> namesEl.value = demo.join('\n'));

  // ---- TEAM logic ----
  let teams = []; // {id,name,members:[],sales:[],requiredSims:10,abilityCount:0,lastRemoved:false,isCaptain:false}
  function resetTeams(){
    teams = [];
    renderTeamSelect();
    results.innerHTML = '';
    manualTeamsList.innerText = '';
  }
  resetTeams();

  addManualTeam.addEventListener('click', ()=>{
    const name = manualTeamName.value.trim();
    if(!name) return alert('Enter a team name');
    teams.push({id:cryptoRandomId(), name, members:[], sales:[], requiredSims:10, abilityCount:0, lastRemoved:false, isCaptain:false});
    manualTeamName.value = '';
    renderManualList();
    renderTeamSelect();
    renderTeamsCards();
  });

  function cryptoRandomId(){ return Math.random().toString(36).slice(2,9); }

  function renderManualList(){
    manualTeamsList.innerHTML = '';
    teams.forEach(t=>{
      const d = document.createElement('div');
      d.style.marginBottom='6px';
      d.innerHTML = `<strong>${t.name}</strong> — required:${t.requiredSims} • sales:${t.sales.length}`;
      manualTeamsList.appendChild(d);
    });
  }

  // create teams from names randomizer
  function createTeams(){
    const raw = namesEl.value.split('\n').map(s => s.trim()).filter(Boolean);
    if(raw.length === 0){
      alert('Add at least one name.');
      return;
    }
    const teamsCount = parseInt(teamsCountEl.value,10) || 4;
    const teamSize = parseInt(teamSizeEl.value,10) || 2;
    const names = shuffleArr(raw.slice());

    // clear previous teams
    teams = Array.from({length:teamsCount}, (_,i)=>({id:cryptoRandomId(), name:`Team ${i+1}`, members:[], sales:[], requiredSims:10, abilityCount:0, lastRemoved:false, isCaptain:false}));

    if(!allowUneven.checked){
      // fill to honor teamSize first then round-robin
      let idx = 0;
      for(let i=0;i<names.length;i++){
        teams[idx].members.push(names[i]);
        idx = (idx+1) % teamsCount;
      }
    } else {
      for(let i=0;i<names.length;i++){
        teams[i % teamsCount].members.push(names[i]);
      }
    }

    renderTeamsCards();
    renderTeamSelect();
    renderManualList();
  }
  shuffleBtn.addEventListener('click', createTeams);
  clearBtn.addEventListener('click', ()=>{ namesEl.value=''; results.innerHTML=''; teams=[]; renderTeamSelect(); manualTeamsList.innerHTML=''; });

  function renderTeamsCards(){
    results.innerHTML = '';
    teams.forEach((t,i)=>{
      const el = document.createElement('div');
      el.className = 'team';
      el.innerHTML = `<div class="badge">T${i+1}</div>
        <div>
          <div style="font-weight:800;margin-bottom:6px">${t.name} ${t.isCaptain? '• Captain' : ''}</div>
          <div class="members">${t.members.map(m=>`<div class="member">${m}</div>`).join('')}</div>
          <div style="margin-top:8px;font-size:13px;color:var(--muted)">Req: ${t.requiredSims} • Abilities: ${t.abilityCount} • Sales recorded: ${t.sales.length}</div>
        </div>`;
      results.appendChild(el);
    });
  }

  function renderTeamSelect(){
    teamSelect.innerHTML = '';
    if(teams.length === 0){
      const opt = document.createElement('option'); opt.value=''; opt.innerText='— no teams —'; teamSelect.appendChild(opt); return;
    }
    teams.forEach(t=>{
      const opt = document.createElement('option'); opt.value = t.id; opt.innerText = `${t.name} (Req:${t.requiredSims} Ab:${t.abilityCount})`;
      teamSelect.appendChild(opt);
    });
  }

  // ---- SALES & ability rules ----
  // record a single sale for selected team
  recordSale.addEventListener('click', ()=>{
    const t = getSelectedTeam();
    if(!t) return alert('Select a team first');
    const s = parseInt(saleSize.value,10);
    if(isNaN(s) || s <= 0) return alert('Enter a sale size (number)');
    // rule: single sale >= requiredSims grants one ability to remove a tile
    t.sales.push({size:s, time:Date.now()});
    if(s >= t.requiredSims){
      t.abilityCount += 1; // one tile removal grant
      log(`${t.name} recorded a qualifying sale of ${s} sims → +1 tile removal ability`);
    } else {
      log(`${t.name} recorded a sale of ${s} sims (does not qualify for immediate removal - single sale must be >= ${t.requiredSims})`);
    }
    saleSize.value = '';
    renderTeamsCards();
    renderTeamSelect();
  });

  function getSelectedTeam(){
    const idv = teamSelect.value;
    return teams.find(t=>t.id === idv);
  }

  // ---- TILES & removal ----
  const TILE_COUNT = 9;
  let tileState = []; // {revealed:false, content:"..."}
  let puzzleAnswer = '';

  function buildTiles(){
    tilesContainer.innerHTML = '';
    tileState = Array.from({length:TILE_COUNT}, (_,i)=>({revealed:false, content:`PUZZLE PART ${i+1}`}));
    tileState.forEach((t,i)=>{
      const el = document.createElement('div');
      el.className = 'tile';
      el.dataset.index = i;
      el.innerHTML = `<div>Tile ${i+1}</div>`;
      el.addEventListener('click', ()=> handleTileClick(i));
      tilesContainer.appendChild(el);
    });
    log('Tiles reset.');
  }

  function handleTileClick(i){
    // don't allow clicking tiles directly unless revealed by removal or random reveal
    if(tileState[i].revealed) return;
    alert('Tiles must be revealed by team action (Remove Tile or Reveal Random). Use Remove Tile to consume an ability.');
  }

  removeTileBtn.addEventListener('click', ()=>{
    const t = getSelectedTeam();
    if(!t) return alert('Select a team first');
    // team must have abilityCount > 0
    if(t.abilityCount <= 0){
      alert(`${t.name} has no removal abilities. You need at least one qualifying single sale >= ${t.requiredSims}.`);
      return;
    }
    // pick an unrevealed tile (user cannot choose tile index here — random)
    const unrevealed = tileState.map((s,i)=> s.revealed ? null : i).filter(n=> n !== null);
    if(unrevealed.length === 0){
      alert('All tiles already revealed.');
      return;
    }
    const sel = unrevealed[Math.floor(Math.random()*unrevealed.length)];
    revealTile(sel, t, true);
  });

  function revealTile(i, teamObj, consumedByTeam){
    tileState[i].revealed = true;
    const el = tilesContainer.querySelector(`.tile[data-index="${i}"]`);
    if(!el) return;
    el.classList.add('revealed');
    el.innerHTML = `<div style="text-align:center"><div style="font-size:12px;color:#6b6b6b">Revealed</div><div style="font-weight:800;margin-top:6px">${tileState[i].content}</div></div>`;
    // consume the team's ability if removal was by team
    if(consumedByTeam){
      teamObj.abilityCount = Math.max(0, teamObj.abilityCount - 1);
      teamObj.lastRemoved = true; // mark that they removed a tile this round
      log(`${teamObj.name} removed a tile (consumed ability). They may now guess the puzzle.`);
      renderTeamsCards();
      renderTeamSelect();
      shootConfetti(18);
    } else {
      log(`A tile was revealed (random).`);
    }
  }

  // Reveal random (not consuming a team's ability)
  revealRandom.addEventListener('click', ()=>{
    const unrevealed = tileState.map((s,i)=> s.revealed ? null : i).filter(n=> n !== null);
    if(unrevealed.length === 0) return;
    const sel = unrevealed[Math.floor(Math.random()*unrevealed.length)];
    revealTile(sel, null, false);
  });

  resetTiles.addEventListener('click', ()=>{
    buildTiles();
    // reset per-team lastRemoved flags
    teams.forEach(t=>{ t.lastRemoved = false; });
    renderTeamsCards();
    renderTeamSelect();
  });

  // ---- GUESS logic ----
  submitGuess.addEventListener('click', ()=>{
    const t = getSelectedTeam();
    if(!t) return alert('Select a team first');
    if(!t.lastRemoved){
      alert('A team must remove a tile this round before they are allowed to guess the final puzzle.');
      return;
    }
    const guess = guessInput.value.trim();
    if(!guess) return alert('Enter a guess.');
    // puzzleAnswer may be set by the user in the small admin field
    puzzleAnswer = (puzzleAnswerEl.value || '').trim();
    if(!puzzleAnswer){
      // if not provided, make an example check: we consider puzzle to be "MAGENTA" for demo
      puzzleAnswer = 'MAGENTA';
    }
    if(guess.toLowerCase() === puzzleAnswer.toLowerCase()){
      log(`${t.name} guessed correctly! Winner: ${t.name}`);
      t.isCaptain = true;
      shootConfetti(120);
      // show final reveal of remaining tiles
      tileState.forEach((tile,i)=> { if(!tile.revealed) revealTile(i, null, false); });
      renderTeamsCards();
      renderTeamSelect();
      alert(`${t.name} guessed correctly — they win and will be captains for the next game!`);
    } else {
      // incorrect guess: doubles requiredSims for that team
      t.requiredSims = t.requiredSims * 2;
      t.lastRemoved = false; // must remove again next time
      log(`${t.name} guessed incorrectly. Their required sims doubled to ${t.requiredSims}.`);
      renderTeamsCards();
      renderTeamSelect();
      alert(`Incorrect guess. ${t.name}'s required sims doubled to ${t.requiredSims}.`);
    }
    guessInput.value = '';
  });

  // ---- logging ----
  function log(msg){
    const ts = new Date().toLocaleTimeString();
    gameLog.innerHTML = `<div>[${ts}] ${escapeHtml(msg)}</div>` + gameLog.innerHTML;
  }

  function escapeHtml(s){ return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

  // ---- simple confetti impl ----
  function shootConfetti(particles=40){
    if(!ctx) return;
    const W = confettiCanvas.width;
    const H = confettiCanvas.height;
    const pieces = [];
    const colors = ['#E20074','#FF7AB6','#FFD9EE','#6b6b6b','#FFFFFF'];

    for(let i=0;i<particles;i++){
      pieces.push({
        x: Math.random()*W,
        y: Math.random()*H*0.2,
        vx: (Math.random()-0.5)*6,
        vy: 2+Math.random()*6,
        size: 6+Math.random()*8,
        color: colors[Math.floor(Math.random()*colors.length)],
        rot: Math.random()*360,
        drot: (Math.random()-0.5)*8
      });
    }

    let t0 = performance.now();
    let alive = true;
    function frame(now){
      const dt = (now - t0)/1000;
      t0 = now;
      ctx.clearRect(0,0,W,H);
      pieces.forEach(p=>{
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.2; // gravity
        p.rot += p.drot;
        ctx.save();
        ctx.translate(p.x,p.y);
        ctx.rotate(p.rot * Math.PI/180);
        ctx.fillStyle = p.color;
        ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size*0.6);
        ctx.restore();
      });
      const remaining = pieces.filter(p=>p.y < H + 30);
      if(remaining.length === 0) alive = false;
      if(alive) requestAnimationFrame(frame);
      else ctx.clearRect(0,0,W,H);
    }
    requestAnimationFrame(frame);
  }

  // ---- init ----
  function init(){
    // prefill demo names
    if(!namesEl.value.trim()){
      namesEl.value = 'Alex\nBailey\nCam\nDiego\nEvelyn\nFrank';
    }
    buildTiles();
    renderTeamSelect();
  }
  init();

})();
